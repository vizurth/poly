{
	\section{Транспортная задача. Алгоритмы Диница и Кинга. Задачи многокритериальной
оптимизации.}

\section*{Транспортная задача}

Пусть имеется $m$ пунктов производства однородного продукта: $A_1, A_2, \ldots, A_m$ и $n$ пунктов его потребления: $B_1, B_2, \ldots, B_n$.  
В каждом пункте $A_i$ производится $a_i$ единиц продукта, а в каждом пункте $B_j$ потребляется $b_j$ единиц.  
Необходимо составить оптимальный план перевозок.

\subsection*{Математическая модель}
Пусть $x_{ij}$ — объём продукта, перевозимого из $A_i$ в $B_j$.  
Тогда общая стоимость перевозок, которую требуется минимизировать:


\[
\sum_{i=1}^{m} \sum_{j=1}^{n} c_{ij} x_{ij} \rightarrow \min
\]



\section*{Задачи многокритериальной оптимизации}

Пусть имеется несколько целевых функций, которые необходимо максимизировать.  
Основная сложность заключается в том, что максимум одного критерия может сопровождаться неудовлетворительными значениями других.

\subsection*{Методы сведения к однокритериальной задаче}
\begin{itemize}
  \item Выделение главного критерия.
  \item Линейная свёртка.
  \item Максминная свёртка.
  \item Метод идеальной точки.
  \item Оптимальность по Парето, по Слейтору, по Никоретте.
\end{itemize}

\subsection*{Метод последовательных уступок}
\begin{enumerate}
  \item Находим максимальное значение самого важного критерия путём решения однокритериальной задачи.
  \item Назначаем допустимое отклонение для первого критерия.
  \item В ограниченной области ищем наилучшее значение второго критерия.
  \item Повторяем процедуру для всех критериев по убыванию важности.
\end{enumerate}

\section*{Алгоритмы Диница и Кинга}

Алгоритмы Диница и Кинга используются для поиска максимального потока в сети.

\subsection*{Алгоритм Диница}

\textbf{Сложность:} $\mathcal{O}(p^2 q)$

\subsubsection*{Инициализация}
\begin{itemize}
  \item Для всех рёбер $(u, v)$ установить поток $f(u, v) := 0$.
  \item Построить остаточную сеть $G_f$ с пропускными способностями $c_f(u, v) := c(u, v) - f(u, v)$.
\end{itemize}

\subsubsection*{Фаза построения слоистой сети (BFS)}
Пока существует путь из $s$ в $t$ в остаточной сети:
\begin{itemize}
  \item Построить слоистую сеть (level graph) обходом в ширину из $s$.
  \item Для каждой вершины $v$ вычислить $level[v]$ — расстояние от $s$ до $v$.
  \item Ребро $(u, v)$ включается, если $level[v] = level[u] + 1$ и $c_f(u, v) > 0$.
\end{itemize}

\subsubsection*{Фаза блокирующего потока (DFS)}
Пока в слоистой сети существует путь из $s$ в $t$:
\begin{itemize}
  \item Найти блокирующий поток с помощью обхода в глубину.
  \item Для каждого найденного пути $p$:
  \begin{itemize}
    \item Найти минимальную остаточную пропускную способность:
    

\[
    c_f(p) := \min\{c_f(u, v) \mid (u, v) \in p\}.
    \]


    \item Увеличить поток вдоль пути: $f(u, v) := f(u, v) + c_f(p)$.
    \item Обновить обратные рёбра: $f(v, u) := f(v, u) - c_f(p)$.
  \end{itemize}
\end{itemize}

\subsubsection*{Завершение}
Если BFS не достигает $t$, алгоритм завершает работу.  
Максимальный поток равен сумме потоков из $s$ в смежные вершины.

\subsection*{Алгоритм Кинга}

\textbf{Сложность:} $\mathcal{O}(nm)$

\section*{Игра на двудольном графе}

Рассмотрим неориентированный двудольный граф $G = (U, V, E)$, где $|U| = |V| = n$, $|E| = m$.

\subsection*{Правила игры}

\textbf{Инициализация:}  
Алгоритм-игрок назначает дугу каждой вершине из множества $U$.

\textbf{Ходы соперника:}
\begin{itemize}
  \item Удалить любую дугу из графа (\textbf{edge-kill}) — очки не начисляются.
  \item Удалить любую вершину из множества $V$ вместе с инцидентными ей дугами — начисляется по одному очку за каждую удалённую дугу.
\end{itemize}

\textbf{Ходы алгоритма-игрока:}
\begin{itemize}
  \item Назначить дугу вершине $u \in U$, если дуга ещё не назначена.
  \item Назначить новую инцидентную дугу вершине $u$ — старая дуга теряет специальный статус, а соперник получает дополнительное очко.
\end{itemize}

\subsection*{Стратегия алгоритма-игрока}

Пусть $l$ — минимальный коэффициент (степень) вершин $u$.  
Обозначим $U' \subseteq U$ — множество вершин с коэффициентом больше $l$.

Для каждой вершины $v \in V$ определим оценку $r(v)$ — число назначенных дуг $(u, v)$, где $u$ имеет минимальный коэффициент.

Разделим диапазон значений $r(v)$ на уровни:  
Уровень $i$ содержит вершины $v$, для которых $r(v) \in [r_i, r_{i+1})$, где $r_i = 2^i$.

При назначении дуги вершине $u \in U'$, алгоритм выбирает дугу, инцидентную вершине $v$ с минимальным уровнем.





    \newpage
}
